\chapter{Avancement de la construction système}

\section{Système de vision}

Le framework Open CV est utilisé pour appliquer des filtres et des traitements permettant de détecter le contenu de la carte soit
les îles, les trésors, la station de recharge et la position du robot. La création de fonctions utilitaires de type pipe and filter
permet de tester plus facilement quels filtres sont efficaces et à quel moment, car l'image initiale n'est pas modifiée dans le
traitement. Il est donc possible de voir l'effet de chaque filtre à tout moment. De plus, nous avons créé une configuration
pour les paramètres qui permet de les modifier et de facilement détecter lesquels sont les plus efficaces. Éventuellement, des
tests automatisés seront réalisés avec un grand échantillon d'images afin d'ajouter de la robustesse à nos algorithmes de détection.
Une fois la position des objets détectée, elle est envoyée au robot qui crée la grille utilisée dans la recherche de chemin.


La caméra monde est utilisée au début pour détecter les objets de la carte et construire la grille pour la recherche de chemin. Elle envoie aussi à intervalle régulier la position du robot au robot. La caméra embarquée, quant à elle, est utilisée pour avoir des précisions sur le positionnement précis du robot près de la station de recharge, avant de ramasser le trésor et avant de déposer le trésor.

\section{Tests}
La partie logicielle comporte bien sûr des tests unitaires qui assurent la maintenabilité et la clarté du code.
Les tests fonctionnels peuvent être effectués à l'aide d'un simulateur qui remplace le robot physique.
On peut paramétrer ce simulateur afin qu'il induise du bruit dans le système et soit donc ainsi plus difficile à contrôler.
Ce simulateur est contrôlé par la vraie interface utilisateur du système.
Il suffit de changer le robot dans un fichier de configuration.
Ce fichier de configuration nous permet d'injecter différentes composantes selon le contexte d'exécution.

\section{Interface}
Afin d'obtenir une interface modulaire et la plus polyvalente possible nous avons opté pour une interface web.
Une composante de notre système s'occupe donc de servir les fichiers nécessaires à l'application web.
Celle-ci communique par HTTP REST ou par socket aux autres composantes du système.
La communication par socket est utilisée lorque nous avons besoin d'une boucle de rétroaction rapide,
comme dans le cas de l'information de position du robot.
La section représentant le monde de jeu de l'interface peut afficher beaucoup d'informations.
Afin de ne pas la surcharger, nous avons opté pour que chacun des affichages soit optionnel et puisse donc
être ajouté ou enlevé indépendamment, formant ainsi différentes couches.
Du point de vue des technologies, nous avons utilisé Bootstrap et AngularJS de manière à construire rapidement une interface fonctionnelle.
Pour dessiner les différents éléments de la carte, nous utilisons EaselJS qui nous permet d'utiliser des fonctions avancées de dessin.


\section{Microcontroleur}

Comme interface entre le logiciel et les composantes physique, nous avons choisi d’utiliser un Arduino Mega 2560. Celui-ci possède une puce différente des autres Arduino, la Atmel2560, qui permet entre autres d’utiliser plus de de compteur et plus de canaux d’intérruption, fonctionalités qui seront toutes utilisées dans le cadre du projet. Les avantages d’utiliser un Arduino par rapport à un autre type de microcontroleur sont nombreux. Comme ils sont largement utilisés et qu’ils font partie d’une communauté ouverte, de nombreuses librairies et exemples de toutes sortes sont disponibles en ligne, permettant de prototyper rapidement différents types de projet. De plus, de nombreuses fonctions de bases comme la communication série, les sorties PWM et les entrées ADC sont prises en charge par la librairie Arduino par défaut.

\section{Communication série}

La communication entre l’ordinateur embarqué et le Mega se fait par communication série. La librairie PySerial sur Linux et la librairie Serial sur Arduino assure une communication de base simple et efficace. Les communications sont toute commandé par l’ordinateur embarqué. Le Mega attend constamment une nouvelle commande à exécuter. Il envoit seulement de l’information sur demande, par exemple le voltage du condensateur de l’électroaimant ou le code manchester. Pour l’instant, le Arduino peut faire les fonctions suivantes:

\begin{enumerate}

\item move() - permet d’aller dans n’importe direction à la distance et vitesse désirée
\item rotate() -  permet de de tourner avec la direction et l’angle désiré
\item manchester() - retourne par interface série la lettre décodée du code manchester
\item stop() - cesse tout mouvement en cours
\item magnet() - active ou désactive l’alimentation de l’électroaimant
\item lift() - active le préhenseur pour soulever l’aimant
\item capacitor() - retourne par interface série le voltage du condensateur de l’électroaimant
\end{enumerate}

Les fonctions et leurs arguments sont traduits par un décodeur série. Celui-ci interprète les différents octets selon un code préétabli.

\section{Moteurs}

\subsection{Interface moteur}

Chaque moteur est commandé par un canal via le pont H. Le Arduino se charge d’envoyer les bits de contrôles appropriés à chaque canal selon la commande désirée. Cela permet de contrôler la puissance fournie aux moteurs ainsi que la direction de rotation. Chaque moteur possède les fonctions suivantes:

\begin{enumerate}
\item set() - Détermine la vitesse désirée, la distance et la direction
\item reset() - Remet tous les paramètres d’un moteur à zéro
\item start() - Démarre le régulateur PID pour un moteur avec les paramètre établis avec le dernier set()
\item brake() - Arrête la roue mais conserve la dernière commande
\end{enumerate}

Également, chaque pair de moteur qui ont la même orientation sont associée par la fonction $move_straight()$. Celle-ci indique au régulateur que ces deux moteurs doivent avoir la même vitesse en tout temps. Le régulateur va alors constamment regarder la différence de vitesse et de position entre les deux afin de les synchroniser.

\subsection{Régulation des moteurs}

Chaque moteur est réguler principalement en vitesse. Un timer active le PID à toutes les 50 ms afin de calculer la vitesse de chaque moteur et l’erreur par rapport à la commande. La sortie est un canal PWM pour chaque moteur qui est envoyé au pont H. Également, lorsqu’une commande $move_straight()$ est appelée, un autre PID cette fois en position est activée afin de synchroniser les moteurs qui ont la même orientation. Le régulateur stop automatiquement les moteurs lorsque la distance à parcourir est terminée. L'acquisition de la position des moteurs avec les encodeurs se fait directement à l’aide de canaux d’interruption qui incrémentent chacun un compteur. La résolution utilisé des encodeurs est de 1600 ticks par révolution de roue, soit le front montant d’un seul canal par encodeur.


\subsection{Acquisition du code Manschester}

Le microcontrôleur Arduino Mega sert également à faire la réception du code Manchester. En effet, un récepteur de fréquence radio RF433 est connecté à l’interface série RX1 du microcontrôleur.

Le message provient d’un second Arduino Mega situé à la station de recharge, qui a comme fonction de diffuser en continu le code Manchester. Un transmetteur RF433 compatible avec le récepteur du robot est donc branché sur l’interface série TX1, diffusant les 32 bits du message sans arrêt, utilisant un protocole série. Aucun traitement n’est fait sur le message par le microcontrôleur. Il ne fait que l’acquisition et la transmission du message. Cette acquisition se fait à une fréquence de 4.9 kHz. Une synchronisation est effectuée à chaque coup d’horloge afin d’éviter un déphasage.

Les 32 bits du messages sont écrit en continu sur le canal série, avec un baudrate de 1200 Afin d’éviter les erreurs de transmission. Ensuite, lorsque le microcontrôleur du robot reçoit la commande $manchester()$ par l’ordinateur embarqué, il lit son buffer de réception RX1, qui contient alors les 32 bits du message. Ces bits sont en ordre, mais ne commencent pas nécessairement par le premier. Ils sont donc lus de manière circulaire, jusqu’à ce que les bits de départ et de fins soient identifiés. Ensuite, ces bits sont décodés selon un encodage Manchester, et le message caché est retourné à l’ordinateur de base par série.

\subsection{Contrôle de l'électroaimant et du préhenseur}

L’activation de l’électroaimant et du bras préhenseur se fait également par le microcontrôleur embarqué sur le robot. Lorsque l’instruction d’activation de l’électroaimant est reçue, un simple signal digital 0V-5V est envoyé au module de l’électroaimant. Le courant dans la bobine est ensuite asservi par un régulateur analogique, ce qui évite du travail supplémentaire au microcontrôleur. Il en est également de même pour le préhenseur: lorsque l’instruction provenant de l’ordinateur de base est reçue, un signal 5V est envoyé au préhenseur.

La tension des condensateurs est également lue par une entrée ADC du microcontroleur. Lors de la recharge des condensateurs, cette tension permet de savoir la progression de la recharge. Lors du transport du trésor, cette même mesure permet d’estimer le temps restant avant que l’électroaimant n’ai plus de puissance. Puisque la tension des condensateurs est l’un des éléments à afficher dans l’interface de la station de base, elle peut être transmise par série à l’ordinateur embarqué lorsque la méthode $capacitor()$ est appelée.

\subsection{Contrôle de la caméra}

La caméra embarquée peut tourner sur deux axes à l’aide de servomoteurs HS-422. Ces moteurs sont contrôlés par un Pololu Maestro. Ce microcontrôleur est alimenté par une source de tension 5V, qui permet également d’alimenter les deux moteurs. Le Pololu est commandé par des commandes séries provenant de l’ordinateur de base, par un câble USB. Afin de faciliter le contrôle des caméras, une librairie python utilisant PySerial a été conçue. Premièrement, elle reconnait automatiquement sur quel port USB se trouve le Pololu, puis permet de bouger les caméras avec des commandes simples permettant de bouger la caméra verticalement et horizontalement. La caméra peut être bouger de 180° sur l’axe horizontal et de 90° sur l’angle vertical : il est inutile de regarder vers le haut. Les commandes ont une précision de 1000 unités par quart de tours, donc de 0.09°. La librairie python permet également de définir une vitesse de mouvement horizontale et verticale, s’il est nécessaire de faire un mouvement de balayage lent.

\input{tex/electroaimant_avancement.tex}
\input{tex/alimentation.tex}
\input{tex/circuit_induction.tex}
