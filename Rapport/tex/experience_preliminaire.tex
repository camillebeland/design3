%!TEX encoding = IsoLatin
\chapter{Expériences préliminaires}

\section{Arduino Mega}

\section{Pont en H et commande de moteur}

Afin de tester les moteurs, nous avons commencé à interfacer un canal de pont en H avec un moteur et le Arduino. Nous avons donc alimenter le circuit avec une source DC 12 V limitée en courant à 1.5 A. Cette limite fut décidé arbitrairement afin d'éviter de mauvaises surprises. Le moteur fut alimenté par le canal 3. Ensuite, les 3 broches de contrôle du canal 3 furent branchées à 3 broches de sortie du Arduino. Ces broches permettent de contrôler l'activation du moteur, sa direction et sa vitesse.  La broche de vitesse fut branché à une sortie de type PWM 8 bits (256 valeurs). Ainsi, nous avons évalué le seuil de départ à vide de la roue ainsi que la consommation à la vitesse maximale. 

\section{Encodeurs}

L'encodeur sur les roues offre 2 canaux, chacun donnant 16 impulsions par tour de moteur. En comptant les fronts montants et descendants de chaque canal, l'encodeur offre 64 steps par tour de moteur. Avec une transmission 100:1, cela offre un potentiel de 6400 steps par révolution de roue.

\section{Asservissement en vitesse des moteurs}
\section{Observations générales}
  La base en aluminium offre un excellent support aux roues. Cette résistance permet lajout d'étage supérieur tout en conservant la solidité structurale du robot. Les bases des étages supérieurs sont légères et non conductrices. Un centre de gravité relativement bas est nécessaire pour éliminer tout débalancement du robot durant ses déplacements. C'est pourquoi les pièces les plus lourdes se situeront autant que possible sur les étages inférieurs.

Les roues possèdent un jeu de quelques degrés en rotation. Ce degré de liberté n'implique pas l'arbre du moteur. En conséquence, les décodeurs raccordés à l'arbre ne détectent pas ce déplacement supplémentaire. Il reste à déterminer si cette caractéristique peut devenir problématique. 


\section{Communications sans fil}
 Une carte interne sans fils de 2.4Ghz à deux sorties est présente sur la carte mère de l'ordinateur embarqué. L'antenne peut être mise dans l'une ou l'autre des sorties. Lors du démarrage de l'ordinateur, le module de la carte sans fils est chargé et prêt à utilisation. Cette carte permet l'établissement d'une connexion avec le point d'accès eduroam pour avoir accès à internet. 
 
 Une seconde carte sans fils USB de 5Ghz permet la communication entre le robot et la station de base. L'installation du module RTL8812au est essentielle pour établir une connexion avec le point d'accès Design3-3109. Le module est chargé à chaque démarrage du système d'exploitation Fedora. Une simple configuration en mode graphique permet une connexion automatique lorsque le réseau est à porter. 

\section{Ordinateur embarqué}
 Le système d'exploitation Fedora est installé. Le système est préconfiguré et la Caméra Logitech C905 est fonctionnelle.  Il y a présence de 4 ports USB 2.0 et 2 ports USB 3.0, ce qui est amplement suffisant pour nos besoins. L'ordinateur embarqué peut être alimenté de deux façons, avec un transformateur utilisant la prise murale ou avec une batterie et un régulateur d'alimentation. Chaque méthode possède sa propre fiche d'alimentation sur le panneau arrière de l'ordinateur. 


\section{Alimentation}
  La prise murale utilise une alimentation de 19VDC/4,74A et le régulateur d'alimentation offrent 19VDC/3.5A. Le disque dur SSD nécessite 3.3V et 0.95A. La Caméra Logitech C905, l'Arduino et la carte sans fils DWA-171 sont alimentés par un port USB 2.0 de 5V, 500mA. Les décodeurs ont besoin de 5V, 10mA et sont alimentés par l'Arduino. Le contrôleur de servomoteurs est alimenté en USB 3.0, soit 5V, 900mA. Les deux servomoteurs sont alimentés par le contrôleur de servomoteurs. Les servomoteurs consomment 5V, 150mA lorsqu'ils sont en mouvement sans charge. Le pont en H peut consommer 12V,3A et il alimente au total quatre moteurs roux de 12V.

\section{Consommation maximale}
L'ordinateur embarqué consomme 36W, et inclut le disque dur SSD. La Caméra, l'Arduino et la carte sans DWA-171 utilisent chacun 2.5W. Le contrôleur de servomoteurs lui consomme 4.5W parce qu'il alimente les deux servomoteurs HS-422. Le pont H avec les moteurs roues utilise 36W. L'alarme Lipo et les régulateurs reste à déterminé. 

\section{Démarrage au boot}
La configuration générique de l'ordinateur embarqué proposait au démarrage une liste avec différente options à exécuter qui est gérer par GRUB. Pour l'instant, nous avons simplement éliminé cette liste de choix et exécutons directement le noyaux 4.2.8-200 avec l'interface graphique légère de base proposé par le cours. De plus, nous sommes fort heureux de savoir que les configurations ont été faite en MBR et non en UEFI. Ceci facilite la tâche lorsqu'il y a plusieurs système d'exploitation sur un même disque. Par contre, pour l'instant, il semble inutile de faire l'installation d'un deuxième système d'exploitation. Il est fort probable qu'éventuellement il y aura élimination de l'interface graphique, séquençage et restriction du nombre de module exécuté au démarrage. C'est-à-dire désactivation des périphériques superflues. Il reste à déterminé si la recompilation du noyau est avantageuse une fois les correctifs apportés.  


\section{Recherche de chemin}
Il y a plusieurs façons de rechercher un chemin entre un point A et un point B.
La première consiste à discrétiser l'espace, soit de séparer l'espace en
petits éléments.  On construit avec ces éléments un graphe ou chaque élément
constitue un noeud du graphe et les éléments adjacents sont reliés par une arête
du graphe avec un point correspondant a la distance entre les centres des
éléments.  Les obstacles peuvent être simplement retiré du graphe ou encore le
poids peut simplement être augmenté artificiellement pour éviter de passer par
l'obstacle.  Ainsi, la recherche du chemin optimal revient à utiliser un
algorithme de recherche de chemin dans un graphe.  Les algorithmes de Dijkstra
ou A* sont d'excellents candidats pour effectuer cette tâche.

La deuxième technique consiste à représenter tous les points par une énergie
correspondante.  Les chemins souhaitables ont une énergie négative tandis que
les obstacles des énergies positives.  En ajustant le robot pour qu'il passe par
le chemin de moindre énergie, il évite ainsi les obstacles.  Il n'y a aucune
assurance que le chemin trouvé est le chemin optimal.
(http://www.ibm.com/developerworks/java/library/j-antigrav/)

\section{Reconnaissance d'image}