%!TEX encoding = IsoLatin
\chapter{Expériences préliminaires}

\section{Arduino Mega}

Comme microcontrôleur, nous avons décidé d’utilise le Arduino Mega. En plus d’offrir un I/O assez généreux, la facilité d’utilisation et l’énorme communauté Arduino en ligne en font une solution accessible et permettant de déployer rapidement de nouvelles fonctionnalités à partir des nombreuses librairies disponibles en ligne. Un pinout préliminaire fut établi afin de confirmer si la quantité de broches et de périphérique était suffisante.

\section{Pont en H et commande de moteur}

Afin de tester les moteurs, nous avons commencé à interfacer un canal de pont en H avec un moteur et le Arduino. Nous avons donc alimenter le circuit avec une source DC 12 V limitée en courant à 1.5 A. Cette limite fut décidé arbitrairement afin d'éviter de mauvaises surprises. Le moteur fut alimenté par le canal 3. Ensuite, les 3 broches de contrôle du canal 3 furent branchées à 3 broches de sortie du Arduino. Ces broches permettent de contrôler l'activation du moteur, sa direction et sa vitesse.  La broche de vitesse fut branché à une sortie de type PWM 8 bits (256 valeurs). Ainsi, nous avons évalué le seuil de départ à vide de la roue ainsi que la consommation à la vitesse maximale. 

\section{Encodeurs}

L'encodeur sur les roues offre 2 canaux, chacun donnant 16 impulsions par tour de moteur. En comptant les fronts montants et descendants de chaque canal, l'encodeur offre 64 steps par tour de moteur. Avec une transmission 100:1, cela offre un potentiel de 6400 steps par révolution de roue, ce qui est beaucoup, voir trop pour notre application.  Comme premier test, on a branché le canal 1 des 4 encodeurs sur 4 broches d'interruption du Arduino Mega. La fonction ISR de chaque canal d'interruption fut configuré afin de compter le nombre de fronts montants. Pour l'instant, la quantité d'interruption ne semble pas causer de problème à l'intérieur de la boucle principale du programme, mais d'autres tests seront nécéssaire afin d'assurer la robustesse de ce principe d'aquisition.

\section{Asservissement en vitesse des moteurs}

Des tests préliminaires d'asservissement en vitesses furent effectués sur 2 roues comme preuve de concept. Ainsi, un intervalle dt fut établi à 100 ms. Après ce dernier, la vitesse désirée pour chaque roue est comparée avec la vitesse actuelle. Un PID arbitraire fut appliqué ensuite en fonction de cette erreur. Rapidement, on a trouvé des paramètres assez stables, permettant au système de subir quelques perturbations et de revenir rapidement à la vitesse désirée. Durant nos tests, nous avons eu des problèmes à synchroniser deux roues ensemble. En effet, l’utilisation de la fonction AnalogWrite() dans la boucle d’asservissement sur plusieurs broches simultanées entrainait des comportements imprévisibles. Après recherche, nous avons décidé de coder manuellement la fonction de sortie PWM et le problème fut réglé. Par la suite, en comparant la vitesse de deux roues, un facteur supplémentaire fut ajouté à la boucle d’asservissement permettant de ralentir la roue qui va plus vite que l’autre et vice-versa. Ainsi, nos tests préliminaires d’asservissement nous ont permis de synchroniser deux roues en vitesse et en position.

\section{Observations générales}
  La base en aluminium offre un excellent support aux roues. La résistance de la base permet l’ajout d’étage supérieur tout en conservant la solidité structurale du robot. Les bases des étages supérieurs sont légères et non conductrices. Un centre de gravité relativement bas est nécessaire pour éliminer tout débalancement du robot durant ses déplacements. C’est pourquoi les pièces les plus lourdes se situeront autant que possible sur les étages inférieurs.

Les roues possèdent un jeu de quelques degrés en rotation. Ce degré de liberté n’implique pas l’arbre du moteur. En conséquence, les décodeurs raccordés à l’arbre ne détectent pas ce déplacement supplémentaire. Il reste à déterminer si cette caractéristique peut devenir problématique. 

\section{Communications sans fil}
  Une carte interne sans fils de 2.4Ghz à deux sorties est présente sur la carte mère de l’ordinateur embarqué. L’antenne peut être mise dans l’une ou l’autre des sorties. Lors du démarrage de l’ordinateur, le module de la carte sans fils est chargé et prêt à utilisation. Cette carte permet l’établissement d’une connexion avec le point d’accès eduroam pour avoir accès à internet. 
 
 Une seconde carte sans fils USB de 5Ghz permet la communication entre le robot et la station de base. L’installation du module RTL8812au est essentielle pour établir une connexion avec le point d’accès Design3-3109. Le module est chargé à chaque démarrage du système d’exploitation Fedora. Une simple configuration en mode graphique permet une connexion automatique lorsque le réseau est à porter. 

\section{Ordinateur embarqué}
Le système d’exploitation Fedora est installé par défaut. Le système est préconfiguré et la Caméra Logitech C905 est fonctionnelle.  Il y a présence de 4 ports USB 2.0 et 2 ports USB 3.0, ce qui est amplement suffisant pour nos besoins. L’ordinateur embarqué peut être alimenté de deux façons, avec un transformateur utilisant la prise murale ou avec une batterie et un régulateur d’alimentation. Chaque méthode possède sa propre fiche d’alimentation sur le panneau arrière de l’ordinateur. 


\section{Alimentation}
   La prise murale de l'ordinateur utilise une alimentation de 19VDC/4,74A et le régulateur d’alimentation fournie 19VDC/3.5A. Le disque dur SSD nécessite 3.3V/0.95A. La Caméra Logitech C905, l’Arduino et la carte sans fils DWA-171 sont alimentés par un port USB 2.0 de 5V, 500mA. Les décodeurs ont besoin de 5V, 10mA et sont alimentés par l’Arduino. Le contrôleur de servomoteurs est alimenté en USB 3.0, soit 5V/900mA, parce qu'il alimente à son tour deux servomoteurs servant à l'ajustement de la caméra Logitech. Les servomoteurs HS-422 sont alimentés en 5V, et utilisent 150mA lorsqu’ils sont en mouvement sans charge. Le pont en H peut consommer 12V,3A et il alimente au total quatre moteurs de 12V. L'agencement et le branchement des différentes composantes dans le présent document sont assujettis à tout changement et à n'importe quel moment. Ceci étant dit, toutes modifications de la distributions de l'alimentation outre que celle décrite demandera une seconde évaluation.  

\section{Consommation maximale}
L’ordinateur embarqué est alimenté par le régulateur d'alimentation fourni dans le cadre du cours. Selon les spécifications présentent sur le site web du cours design3, l'ordinateur consomme au maximum 36W et cette puissance inclut le disque SSD. La Caméra Logitech, les décodeurs alimentés par l’Arduino et la carte sans fils DWA-171 utilisent chacun 2.5W, pour un total de 7,5W. Le contrôleur de servomoteurs consomme 4.5W et cette puissance comprend les deux servomoteurs HS-422. Le pont H et les moteurs roues dépense 36W. La consommation de l’alarme Lipo est négligeable étant donné que nos calculs sont effectués sur une base approximative. Les pertes en puissance du régulateur d'alimentation électronique de l'ordinateur sont estimées à partir de la différence entre le voltage avec et sans charge, soit 1,5V et un courant débité maximal de 3.5A. Il y a alors une perte en puissance d'environ 5W. Le dévolteur de 3A nécessaire pour l'alimentation du pont H a une efficacité estimée de 92\%. La perte de puissance est alors approximativement de 3W.

\section{La batterie}
Le raisonnement débouchant sur le choix de la batterie s'est d'abord basé sur le fait que le régulateur d'alimentation électrique de l'ordinateur embarqué demande une tension de 21V à 30V. À partir de cette restriction, et de la connaissance des différentes tensions  requises pour l'ensemble des composantes du robot, il a été conclu que la présence de dévolteur est nécessaire. Il est estimé que le régulateur d'alimentation de l'ordinateur peut fournir au maximum 66W et qu'il consomme 5W. Ceci est amplement suffisant pour fournir en puissance l'ordinateur embarqué et ses périphériques qui consomment 48W durant les demandes les plus importantes. La batterie doit aussi alimenter le pont H qui exige en période de pointe 36W et des pertes de 3W sont associées au dévolteur. Il y a, au maximum, 92W de puissance consommés par le robot. De plus, la dépense en puissance des roues motrices est fonction du poids du robot. Étant donné que la batterie est fixée au robot, son poids importe. Ainsi, il semble raisonnable de  minimiser le poids de la batterie pour un maximum de puissance, soit une densité massique (Wh/kg) le plus élevée possible. Sachant que les périodes de tests peuvent être longues et que la recharge d'une batterie est considérable, il est préférable d'opter pour une batterie longue durée. Le choix de la batterie s'est fait en fonction des exigences fixées et des couts d'acquisition. Une batterie de type LiPo 6S avec une puissance de 115 Wh a été sélectionnée. Ceci permet, selon nos estimations, une période d'utilisation minimale de 1h15. Finalement, pour des raisons de sécurité, l'acquisition d'une alarme basse tension de la batterie s'est avérée essentielle. 


\section{Démarrage au boot}
La configuration générique de l’ordinateur embarqué proposait au démarrage une liste avec différentes options à exécuter qui est gérée par GRUB. Pour l’instant, nous avons simplement éliminé cette liste de choix et exécutons directement le noyau 4.2.8-200 avec l’interface graphique légère de base proposée par le cours. De plus, nous sommes fort heureux de savoir que les configurations ont été faites en MBR et non en UEFI. Ceci facilite la tâche lorsqu’il y a plusieurs systèmes d’exploitation sur un même disque. Par contre, pour l’instant, il semble inutile de faire l’installation d’un deuxième système d’exploitation. Il est fort probable, qu’éventuellement, il y ait élimination de l’interface graphique, séquençage et restriction du nombre de module exécuté au démarrage. C’est-à-dire, la désactivation des périphériques superflue. Il reste à déterminer si la recompilation du noyau est avantageuse une fois les correctifs apportés.    


\section{Recherche de chemin}
Il y a plusieurs façons de rechercher un chemin entre un point A et un point B.
La première consiste à discrétiser l'espace, soit de séparer l'espace en
petits éléments.  On construit avec ces éléments un graphe ou chaque élément
constitue un noeud du graphe et les éléments adjacents sont reliés par une arête
du graphe avec un point correspondant a la distance entre les centres des
éléments.  Les obstacles peuvent être simplement retiré du graphe ou encore le
poids peut simplement être augmenté artificiellement pour éviter de passer par
l'obstacle.  Ainsi, la recherche du chemin optimal revient à utiliser un
algorithme de recherche de chemin dans un graphe.  Les algorithmes de Dijkstra
ou A* sont d'excellents candidats pour effectuer cette tâche.

La deuxième technique consiste à représenter tous les points par une énergie
correspondante.  Les chemins souhaitables ont une énergie négative tandis que
les obstacles des énergies positives.  En ajustant le robot pour qu'il passe par
le chemin de moindre énergie, il évite ainsi les obstacles.  Il n'y a aucune
assurance que le chemin trouvé est le chemin optimal.
(http://www.ibm.com/developerworks/java/library/j-antigrav/)

\section{Reconnaissance d'images}
Afin d'expérimenter la reconnaissance d'images, nous sommes allés prendre des photos de la table de jeu avec des îles placées aléatoirement. Les photos ont
été prises par la caméra monde. Ensuite, nous avons effectué certains traitements sur ces photos avec OpenCV afin d'avoir une idée de ce qui était possible de détecter. Nous avons réussi à détecter les coins de la carte et à isoler les formes
des îles.

\section{Réflexion sur l'architecture du système}
Afin de faire les diagrammes demandés au livrable 1, nous avons pensé à une architecture possible pour le système et avons déterminé les traitements qui allaient être effectués sur la station de base et ceux qui allaient plutôt être effectués sur le robot. Nous avons exploré plusieurs techniques qui permettent de passer l'information entre les différentes composantes du système et notre
choix s'est arrêté sur les websockets. Nous avons aussi décidé d'utiliser le langage de programmation Python pour la logique haut-niveau du système.

\section{Simulateur de robot et interface web}
Nous avons commencé à programmer, en Python, un simulateur pour le robot. Celui-ci contient des fonctions qui simulent les déplacements du robot sur la carte et enregistre sa position. Nous avons aussi développé une interface web qui est connectée au simulateur de robot par websocket. L'interface communique, à chaque seconde, avec le sereur qui héberge le simulateur afin de recevoir la position du robot qui est ensuite affichée dans un navigateur web.
