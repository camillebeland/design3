%!TEX encoding = IsoLatin
\chapter{Expériences préliminaires}

\section{Arduino Mega}

Comme microcontrôleur, nous avons décidé d’utilise le Arduino Mega. En plus d’offrir un I/O assez généreux, la facilité d’utilisation et l’énorme communauté Arduino en ligne en font une solution accessible et permettant de déployer rapidement de nouvelles fonctionnalités à partir des nombreuses librairies disponibles en ligne. Un pinout préliminaire fut établi afin de confirmer si la quantité de broches et de périphérique était suffisante.

\section{Pont en H et commande de moteur}

Afin de tester les moteurs, nous avons commencé à interfacer un canal de pont en H avec un moteur et le Arduino. Nous avons donc alimenter le circuit avec une source DC 12 V limitée en courant à 1.5 A. Cette limite fut décidé arbitrairement afin d'éviter de mauvaises surprises. Le moteur fut alimenté par le canal 3. Ensuite, les 3 broches de contrôle du canal 3 furent branchées à 3 broches de sortie du Arduino. Ces broches permettent de contrôler l'activation du moteur, sa direction et sa vitesse.  La broche de vitesse fut branché à une sortie de type PWM 8 bits (256 valeurs). Ainsi, nous avons évalué le seuil de départ à vide de la roue ainsi que la consommation à la vitesse maximale. 

\section{Encodeurs}

L'encodeur sur les roues offre 2 canaux, chacun donnant 16 impulsions par tour de moteur. En comptant les fronts montants et descendants de chaque canal, l'encodeur offre 64 steps par tour de moteur. Avec une transmission 100:1, cela offre un potentiel de 6400 steps par révolution de roue, ce qui est beaucoup, voir trop pour notre application.  Comme premier test, on a branché le canal 1 des 4 encodeurs sur 4 broches d'interruption du Arduino Mega. La fonction ISR de chaque canal d'interruption fut configuré afin de compter le nombre de fronts montants. Pour l'instant, la quantité d'interruption ne semble pas causer de problème à l'intérieur de la boucle principale du programme, mais d'autres tests seront nécéssaire afin d'assurer la robustesse de ce principe d'aquisition.

\section{Asservissement en vitesse des moteurs}

Des tests préliminaires d'asservissement en vitesses furent effectués sur 2 roues comme preuve de concept. Ainsi, un intervalle dt fut établi à 100 ms. Après ce dernier, la vitesse désirée pour chaque roue est comparée avec la vitesse actuelle. Un PID arbitraire fut appliqué ensuite en fonction de cette erreur. Rapidement, on a trouvé des paramètres assez stables, permettant au système de subir quelques perturbations et de revenir rapidement à la vitesse désirée. Durant nos tests, nous avons eu des problèmes à synchroniser deux roues ensemble. En effet, l’utilisation de la fonction AnalogWrite() dans la boucle d’asservissement sur plusieurs broches simultanées entrainait des comportements imprévisibles. Après recherche, nous avons décidé de coder manuellement la fonction de sortie PWM et le problème fut réglé. Par la suite, en comparant la vitesse de deux roues, un facteur supplémentaire fut ajouté à la boucle d’asservissement permettant de ralentir la roue qui va plus vite que l’autre et vice-versa. Ainsi, nos tests préliminaires d’asservissement nous ont permis de synchroniser deux roues en vitesse et en position.

\section{Observations générales}
  La base en aluminium offre un excellent support aux roues. Cette résistance permet lajout d'étage supérieur tout en conservant la solidité structurale du robot. Les bases des étages supérieurs sont légères et non conductrices. Un centre de gravité relativement bas est nécessaire pour éliminer tout débalancement du robot durant ses déplacements. C'est pourquoi les pièces les plus lourdes se situeront autant que possible sur les étages inférieurs.

Les roues possèdent un jeu de quelques degrés en rotation. Ce degré de liberté n'implique pas l'arbre du moteur. En conséquence, les décodeurs raccordés à l'arbre ne détectent pas ce déplacement supplémentaire. Il reste à déterminer si cette caractéristique peut devenir problématique. 


\section{Communications sans fil}
 Une carte interne sans fils de 2.4Ghz à deux sorties est présente sur la carte mère de l'ordinateur embarqué. L'antenne peut être mise dans l'une ou l'autre des sorties. Lors du démarrage de l'ordinateur, le module de la carte sans fils est chargé et prêt à utilisation. Cette carte permet l'établissement d'une connexion avec le point d'accès eduroam pour avoir accès à internet. 
 
 Une seconde carte sans fils USB de 5Ghz permet la communication entre le robot et la station de base. L'installation du module RTL8812au est essentielle pour établir une connexion avec le point d'accès Design3-3109. Le module est chargé à chaque démarrage du système d'exploitation Fedora. Une simple configuration en mode graphique permet une connexion automatique lorsque le réseau est à porter. 

\section{Ordinateur embarqué}
 Le système d'exploitation Fedora est installé. Le système est préconfiguré et la Caméra Logitech C905 est fonctionnelle.  Il y a présence de 4 ports USB 2.0 et 2 ports USB 3.0, ce qui est amplement suffisant pour nos besoins. L'ordinateur embarqué peut être alimenté de deux façons, avec un transformateur utilisant la prise murale ou avec une batterie et un régulateur d'alimentation. Chaque méthode possède sa propre fiche d'alimentation sur le panneau arrière de l'ordinateur. 


\section{Alimentation}
  La prise murale utilise une alimentation de 19VDC/4,74A et le régulateur d'alimentation offrent 19VDC/3.5A. Le disque dur SSD nécessite 3.3V et 0.95A. La Caméra Logitech C905, l'Arduino et la carte sans fils DWA-171 sont alimentés par un port USB 2.0 de 5V, 500mA. Les décodeurs ont besoin de 5V, 10mA et sont alimentés par l'Arduino. Le contrôleur de servomoteurs est alimenté en USB 3.0, soit 5V, 900mA. Les deux servomoteurs sont alimentés par le contrôleur de servomoteurs. Les servomoteurs consomment 5V, 150mA lorsqu'ils sont en mouvement sans charge. Le pont en H peut consommer 12V,3A et il alimente au total quatre moteurs roux de 12V.

\section{Consommation maximale}
L'ordinateur embarqué consomme 36W, et inclut le disque dur SSD. La Caméra, l'Arduino et la carte sans DWA-171 utilisent chacun 2.5W. Le contrôleur de servomoteurs lui consomme 4.5W parce qu'il alimente les deux servomoteurs HS-422. Le pont H avec les moteurs roues utilise 36W. L'alarme Lipo et les régulateurs reste à déterminé. 

\section{Démarrage au boot}
La configuration générique de l'ordinateur embarqué proposait au démarrage une liste avec différente options à exécuter qui est gérer par GRUB. Pour l'instant, nous avons simplement éliminé cette liste de choix et exécutons directement le noyaux 4.2.8-200 avec l'interface graphique légère de base proposé par le cours. De plus, nous sommes fort heureux de savoir que les configurations ont été faite en MBR et non en UEFI. Ceci facilite la tâche lorsqu'il y a plusieurs système d'exploitation sur un même disque. Par contre, pour l'instant, il semble inutile de faire l'installation d'un deuxième système d'exploitation. Il est fort probable qu'éventuellement il y aura élimination de l'interface graphique, séquençage et restriction du nombre de module exécuté au démarrage. C'est-à-dire désactivation des périphériques superflues. Il reste à déterminé si la recompilation du noyau est avantageuse une fois les correctifs apportés.  


\section{Recherche de chemin}
Il y a plusieurs façons de rechercher un chemin entre un point A et un point B.
La première consiste à discrétiser l'espace, soit de séparer l'espace en
petits éléments.  On construit avec ces éléments un graphe ou chaque élément
constitue un noeud du graphe et les éléments adjacents sont reliés par une arête
du graphe avec un point correspondant a la distance entre les centres des
éléments.  Les obstacles peuvent être simplement retiré du graphe ou encore le
poids peut simplement être augmenté artificiellement pour éviter de passer par
l'obstacle.  Ainsi, la recherche du chemin optimal revient à utiliser un
algorithme de recherche de chemin dans un graphe.  Les algorithmes de Dijkstra
ou A* sont d'excellents candidats pour effectuer cette tâche.

La deuxième technique consiste à représenter tous les points par une énergie
correspondante.  Les chemins souhaitables ont une énergie négative tandis que
les obstacles des énergies positives.  En ajustant le robot pour qu'il passe par
le chemin de moindre énergie, il évite ainsi les obstacles.  Il n'y a aucune
assurance que le chemin trouvé est le chemin optimal.
(http://www.ibm.com/developerworks/java/library/j-antigrav/)

\section{Reconnaissance d'images}
Afin d'expérimenter la reconnaissance d'images, nous sommes allés prendre des photos de la table de jeu avec des îles placées aléatoirement. Les photos ont
été prises par la caméra monde. Ensuite, nous avons effectué certains traitements sur ces photos avec OpenCV afin d'avoir une idée de ce qui était possible de détecter. Nous avons réussi à détecter les coins de la carte et à isoler les formes
des îles.

\section{Réflexion sur l'architecture du système}
Afin de faire les diagrammes demandés au livrable 1, nous avons pensé à une architecture possible pour le système et avons déterminé les traitements qui allaient être effectués sur la station de base et ceux qui allaient plutôt être effectués sur le robot. Nous avons exploré plusieurs techniques qui permettent de passer l'information entre les différentes composantes du système et notre
choix s'est arrêté sur les websockets. Nous avons aussi décidé d'utiliser le langage de programmation Python pour la logique haut-niveau du système.

\section{Simulateur de robot et interface web}
Nous avons commencé à programmer, en Python, un simulateur pour le robot. Celui-ci contient des fonctions qui simulent les déplacements du robot sur la carte et enregistre sa position. Nous avons aussi développé une interface web qui est connectée au simulateur de robot par websocket. L'interface communique, à chaque seconde, avec le sereur qui héberge le simulateur afin de recevoir la position du robot qui est ensuite affichée dans un navigateur web.
