%!TEX encoding = IsoLatin

\chapter{Expériences préliminaires}

\section{Observations générales}
  La base en aluminium offre un excellent support aux roues. La résistance de la base permet l’ajout d’étage supérieur tout en conservant la solidité structurale du robot. Les bases des étages supérieurs sont légères et non conductrices. Un centre de gravité relativement bas est nécessaire pour éliminer tout débalancement du robot durant ses déplacements. C’est pourquoi les pièces les plus lourdes se situeront autant que possible sur les étages inférieurs.

Les roues possèdent un jeu de quelques degrés en rotation. Ce degré de liberté n’implique pas l’arbre du moteur. En conséquence, les décodeurs raccordés à l’arbre ne détectent pas ce déplacement supplémentaire. Il reste à déterminer si cette caractéristique peut devenir problématique. 

\section{Arduino Mega}

\section{Pont en H et commande de moteur}

Afin de tester les moteurs, nous avons commencé à interfacer un canal de pont en H avec un moteur et le Arduino. Nous avons donc alimenté le circuit avec une source DC 12 V limitée en courant à 1.5 A. Cette limite fut décidée arbitrairement afin d'éviter de mauvaises surprises. Le moteur fut alimenté par le canal 3. Ensuite, les 3 broches de contrôle du canal 3 furent branchées à 3 broches de sortie du Arduino. Ces broches permettent de contrôler l'activation du moteur, sa direction et sa vitesse.  La broche de vitesse fut branchée à une sortie de type PWM 8 bits (256 valeurs). Ainsi, nous avons évalué le seuil de départ à vide de la roue ainsi que la consommation à la vitesse maximale. 

\section{Encodeurs}

L'encodeur sur les roues offre 2 canaux, chacun donnant 16 impulsions par tour de moteur. En comptant les fronts montants et descendants de chaque canal, l'encodeur offre 64 steps par tour de moteur. Avec une transmission 100:1, cela offre un potentiel de 6400 steps par révolution de roue, ce qui est beaucoup, voir trop pour notre application.  Comme premier test, on a branché le canal 1 des 4 encodeurs sur 4 broches d'interruption du Arduino Mega. La fonction ISR de chaque canal d'interruption fut configurée afin de compter le nombre de fronts montants. Pour l'instant, la quantité d'interruption ne semble pas causer de problème à l'intérieur de la boucle principale du programme, mais d'autres tests seront nécessaires afin d'assurer la robustesse de ce principe d'acquisition.

\section{Asservissement en vitesse des moteurs}

Des tests préliminaires d'asservissement en vitesses furent effectués sur 2 roues comme preuve de concept. 



\section{Ordinateur embarqué}
 Le système d’exploitation Fedora est installé par défaut. Le système est préconfiguré et la Caméra Logitech C905 est fonctionnelle.  Il y a présence de 4 ports USB 2.0 et 2 ports USB 3.0, ce qui est amplement suffisant pour nos besoins. L’ordinateur embarqué peut être alimenté de deux façons, avec un transformateur utilisant la prise murale ou avec une batterie et un régulateur d’alimentation. Chaque méthode possède sa propre fiche d’alimentation sur le panneau arrière de l’ordinateur. 

\section{Communications sans fil}
 Une carte interne sans fils de 2.4Ghz à deux sorties est présente sur la carte mère de l’ordinateur embarqué. L’antenne peut être mise dans l’une ou l’autre des sorties. Lors du démarrage de l’ordinateur, le module de la carte sans fils est chargé et prêt à utilisation. Cette carte permet l’établissement d’une connexion avec le point d’accès eduroam pour avoir accès à internet. 
 
 Une seconde carte sans fils USB de 5Ghz permet la communication entre le robot et la station de base. L’installation du module RTL8812au est essentielle pour établir une connexion avec le point d’accès Design3-3109. Le module est chargé à chaque démarrage du système d’exploitation Fedora. Une simple configuration en mode graphique permet une connexion automatique lorsque le réseau est à porter. 
 
\section{Démarrage au boot}
La configuration générique de l’ordinateur embarqué proposait au démarrage une liste avec différentes options à exécuter qui est gérée par GRUB. Pour l’instant, nous avons simplement éliminé cette liste de choix et exécutons directement le noyau 4.2.8-200 avec l’interface graphique légère de base proposée par le cours. De plus, nous sommes fort heureux de savoir que les configurations ont été faites en MBR et non en UEFI. Ceci facilite la tâche lorsqu’il y a plusieurs systèmes d’exploitation sur un même disque. Par contre, pour l’instant, il semble inutile de faire l’installation d’un deuxième système d’exploitation. Il est fort probable, qu’éventuellement, il y ait élimination de l’interface graphique, séquençage et restriction du nombre de module exécuté au démarrage. C’est-à-dire, la désactivation des périphériques superflue. Il reste à déterminer si la recompilation du noyau est avantageuse une fois les correctifs apportés.  

\section{Alimentation}
  La prise murale de l'ordinateur utilise une alimentation de 19VDC/4,74A et le régulateur d’alimentation fournie 19VDC/3.5A. Le disque dur SSD nécessite 3.3V/0.95A. La Caméra Logitech C905, l’Arduino et la carte sans fils DWA-171 sont alimentés par un port USB 2.0 de 5V, 500mA. Les décodeurs ont besoin de 5V, 10mA et sont alimentés par l’Arduino. Le contrôleur de servomoteurs est alimenté en USB 3.0, soit 5V/900mA, parce qu'il alimente à son tour deux servomoteurs servant à l'ajustement de la caméra Logitech. Les servomoteurs HS-422 sont alimentés en 5V, et utilisent 150mA lorsqu’ils sont en mouvement sans charge. Le pont en H peut consommer 12V,3A et il alimente au total quatre moteurs de 12V. L'agencement et le branchement des différentes composantes dans le présent document sont assujettis à tout changement et à n'importe quel moment. Ceci étant dit, toutes modifications de la distributions de l'alimentation outre que celle décrite demandera une seconde évaluation.  

\section{Consommation maximale}

L’ordinateur embarqué est alimenté par le régulateur d'alimentation fourni dans le cadre du cours. Selon les spécifications présentent sur le site web du cours design3, l'ordinateur consomme au maximum 36W et cette puissance inclut le disque SSD. La Caméra Logitech, les décodeurs alimentés par l’Arduino et la carte sans fils DWA-171 utilisent chacun 2.5W, pour un total de 7,5W. Le contrôleur de servomoteurs consomme 4.5W et cette puissance comprend les deux servomoteurs HS-422. Le pont H et les moteurs roues dépense 36W. La consommation de l’alarme Lipo est négligeable étant donné que nos calculs sont effectués sur une base approximative. Les pertes en puissance du régulateur d'alimentation électronique de l'ordinateur sont estimées à partir de la différence entre le voltage avec et sans charge, soit 1,5V et un courant débité maximal de 3.5A. Il y a alors une perte en puissance d'environ 5W. Le dévolteur de 3A nécessaire pour l'alimentation du pont H a une efficacité estimée de 92\%. La perte de puissance est alors approximativement de 3W.


\section{La batterie}

Le raisonnement débouchant sur le choix de la batterie s'est d'abord basé sur le fait que le régulateur d'alimentation électrique de l'ordinateur embarqué demande une tension de 21V à 30V. À partir de cette restriction, et de la connaissance des différentes tensions  requises pour l'ensemble des composantes du robot, il a été conclu que la présence de dévolteur est nécessaire. Il est estimé que le régulateur d'alimentation de l'ordinateur peut fournir au maximum 66W et qu'il consomme 5W. Ceci est amplement suffisant pour fournir en puissance l'ordinateur embarqué et ses périphériques qui consomment 48W durant les demandes les plus importantes. La batterie doit aussi alimenter le pont H qui exige en période de pointe 36W et des pertes de 3W sont associées au dévolteur. Il y a, au maximum, 92W de puissance consommés par le robot. De plus, la dépense en puissance des roues motrices est fonction du poids du robot. Étant donné que la batterie est fixée au robot, son poids importe. Ainsi, il semble raisonnable de  minimiser le poids de la batterie pour un maximum de puissance, soit une densité massique (Wh/kg) le plus élevée possible. Sachant que les périodes de tests peuvent être longues et que la recharge d'une batterie est considérable, il est préférable d'opter pour une batterie longue durée. Le choix de la batterie s'est fait en fonction des exigences fixées et des couts d'acquisition. Une batterie de type LiPo 6S avec une puissance de 115 Wh a été sélectionnée. Ceci permet, selon nos estimations, une période d'utilisation minimale de 1h15. Finalement, pour des raisons de sécurité, l'acquisition d'une alarme basse tension de la batterie s'est avérée essentielle. 

\section{Électroaimant}
Au niveau de l'électroaimant, la majorité du travail a été  de révisé les notions de magnétisme nécessaire pour la conception d'un électroaimant. La révision s'est effectué sur les sujets suivants: circuits magnétiques, les solénoïdes, le flux magnétique , le champs magnétique et la force crée par un champs magnétique. En plus de cela, on a commencer à examiner les différentes options au niveau du bobinage de la source magnétique. En effet, selon la grosseur de fils qu'on décide de prendre, on augmente ou diminue la résistance électrique ce qui limite la quantité de courant qu'on peut pousser dans la bobine et ainsi notre force magnétomotrice. Finalement, au niveau du matériel, on a regarder les deux options offert par le magasin du département. Il s'agit de coeur de ferrite dans lequel on peut mettre notre bobine. Les deux modèles fournis sont PC-3019 (modèle plus petit) et PC-3622 (modèle plus gros) de la compagnie Elna Ferrite. En se référant au catalogue de code de ferrite d'Elna Ferrite, le symbole C représente les caractéristiques de la pièce. Cela signifie que la pièce est sensé être assez linéaire au niveau de la courbe d'hystérésis et qu'il y a un bon rendement au niveau de l'énergie versus le flux magnétique crée. La prochaine étape de faire un système linéaire du nombre de tours versus le flux magnétique créé afin de trouver les points optimisés.

\section{Code manchester}
On n'a pas jouer directement avec le module de code manchester, à cause que celui-ci n'était pas encore prêt. Mais cependant, on a regardé ce que c'était un code manchester et les divers options pour le transmettre. Aussi c'est nous qui va déterminer la fréquence d'horloge de transmission. Une fréquence en dessous de 100 kHz semble suffisant s'il s'agit de juste transférer un seul byte d'information. Le message n'est pas encodé avec l'horloge en effectuant un XOR avec celle-ci, on transmet directement la lettre du LSB au MSB.Ensuite le protocole de communication se résume à envoyer un bit à 0 , ensutie les 7 bits encodé en manchester suivit enfin de 1 byte d'arrêt à 1. La séquence se répète sans cesse. Pour transmettre ce code sans-fils, deux options semblent être priviligiées. La première consiste à effectuer une modulation numériques notre signal de charge du condensateur. La seconde consisterait a utiliser des modules de type NRF/Zigbee/BlueTooth déjà assemblé. La première option serait à priviliger de par sa simplicité.


