%!TEX encoding = IsoLatin

\chapter{Expériences préliminaires}

\section{Arduino Mega}

\section{Pont en H et commande de moteur}

Afin de tester les moteurs, nous avons commencé à interfacer un canal de pont en H avec un moteur et le Arduino. Nous avons donc alimenter le circuit avec une source DC 12 V limitée en courant à 1.5 A. Cette limite fut décidé arbitrairement afin d'éviter de mauvaises surprises. Le moteur fut alimenté par le canal 3. Ensuite, les 3 broches de contrôle du canal 3 furent branchées à 3 broches de sortie du Arduino. Ces broches permettent de contrôler l'activation du moteur, sa direction et sa vitesse.  La broche de vitesse fut branché à une sortie de type PWM 8 bits (256 valeurs). Ainsi, nous avons évalué le seuil de départ à vide de la roue ainsi que la consommation à la vitesse maximale. 

\section{Encodeurs}

L'encodeur sur les roues offre 2 canaux, chacun donnant 16 impulsions par tour de moteur. En comptant les fronts montants et descendants de chaque canal, l'encodeur offre 64 steps par tour de moteur. Avec une transmission 100:1, cela offre un potentiel de 6400 steps par révolution de roue, ce qui est beaucoup, voir trop pour notre application.  Comme premier test, on a branché le canal 1 des 4 encodeurs sur 4 broches d'interruption du Arduino Mega. La fonction ISR de chaque canal d'interruption fut configuré afin de compter le nombre de fronts montants. Pour l'instant, la quantité d'interruption ne semble pas causer de problème à l'intérieur de la boucle principale du programme, mais d'autres tests seront nécéssaire afin d'assurer la robustesse de ce principe d'aquisition.

\section{Asservissement en vitesse des moteurs}

Des tests préliminaires d'asservissement en vitesses furent effectués sur 2 roues comme preuve de concept. 

\section{Observations générales}
  La base en aluminium offre un excellent support aux roues. Cette résistance permet l’ajout d’étage supérieur tout en conservant la solidité structurale du robot. Les bases des étages supérieurs sont légères et non conductrices. Un centre de gravité relativement bas est nécessaire pour éliminer tout débalancement du robot durant ses déplacements. C’est pourquoi les pièces les plus lourdes se situeront autant que possible sur les étages inférieurs.

Les roues possèdent un jeu de quelques degrés en rotation. Ce degré de liberté n’implique pas l’arbre du moteur. En conséquence, les décodeurs raccordés à l’arbre ne détectent pas ce déplacement supplémentaire. Il reste à déterminer si cette caractéristique peut devenir problématique. 


\section{Communications sans fil}
 Une carte interne sans fils de 2.4Ghz à deux sorties est présente sur la carte mère de l’ordinateur embarqué. L’antenne peut être mise dans l’une ou l’autre des sorties. Lors du démarrage de l’ordinateur, le module de la carte sans fils est chargé et prêt à utilisation. Cette carte permet l’établissement d’une connexion avec le point d’accès eduroam pour avoir accès à internet. 
 
 Une seconde carte sans fils USB de 5Ghz permet la communication entre le robot et la station de base. L’installation du module RTL8812au est essentielle pour établir une connexion avec le point d’accès Design3-3109. Le module est chargé à chaque démarrage du système d’exploitation Fedora. Une simple configuration en mode graphique permet une connexion automatique lorsque le réseau est à porter. 

\section{Ordinateur embarqué}
 Le système d’exploitation Fedora est installé. Le système est préconfiguré et la Caméra Logitech C905 est fonctionnelle.  Il y a présence de 4 ports USB 2.0 et 2 ports USB 3.0, ce qui est amplement suffisant pour nos besoins. L’ordinateur embarqué peut être alimenté de deux façons, avec un transformateur utilisant la prise murale ou avec une batterie et un régulateur d’alimentation. Chaque méthode possède sa propre fiche d’alimentation sur le panneau arrière de l’ordinateur. 


\section{Alimentation}
  La prise murale de l'ordinateur utilise une alimentation de 19VDC/4,74A et le régulateur d’alimentation offre 19VDC/3.5A. Le disque dur SSD nécessite 3.3V/0.95A. La Caméra Logitech C905, l’Arduino et la carte sans fils DWA-171 sont alimentés par un port USB 2.0 de 5V, 500mA. Les décodeurs ont besoin de 5V, 10mA et sont alimentés par l’Arduino. Le contrôleur de servomoteurs est alimenté en USB 3.0, soit 5V/900mA, parce qu'il alimente à son tour deux servomoteurs servant à l'ajustement de la caméra Logitech. Les servomoteurs Hs-222 consomment 5V, 150mA lorsqu’ils sont en mouvement sans charge. Le pont en H peut consommer 12V,3A et il alimente au total quatre moteurs de 12V. Lors de tests à vide, et ce, en présence d'asservisement des quatres roues , l'ensemble des roues consommait 1,5A. 

\section{Consommation maximale}

L’ordinateur embarqué est alimenté par le régulateur d'alimentation fourni dans le cadre du cours. Selon spécifications retrouvé sur le site web de design3, l'ordinateur consomme au maximal 36W et cette puissance inclut le disque SSD. La Caméra Logitech, les décodeurs alimenté par l’Arduino et la carte sans fils DWA-171 utilisent chacun 2.5W, pour un total de 7,5W. Le contrôleur de servomoteurs consomme 4.5W et cette puissance comprends les deux servomoteurs HS-422. Le pont H et les moteurs roues dépense 36W. La consommation de l’alarme Lipo est négligeable étant donné que nos calculs sont effectuée sur une base approximative. Les pertes en puissance du régulateur d'alimentation électronique de l'ordinateur est estimé à partir de la différence entre le voltage avec et sans charge, soit 1,5V et un courrant débité maximal de 3.5A. Il y a alors une perte en puissance de 5,25W. Le dévolteur de 3A nécessaire pour l'alimentation du pont H a une efficacité estimé de 92\%. La perte de puissance est alors approximativement de 3W.

\section{Démarrage au boot}
La configuration générique de l’ordinateur embarqué proposait au démarrage une liste avec différente options à exécuter qui est gérer par GRUB. Pour l’instant, nous avons simplement éliminé cette liste de choix et exécutons directement le noyaux 4.2.8-200 avec l’interface graphique légère de base proposé par le cours. De plus, nous sommes fort heureux de savoir que les configurations ont été faite en MBR et non en UEFI. Ceci facilite la tâche lorsqu’il y a plusieurs système d’exploitation sur un même disque. Par contre, pour l’instant, il semble inutile de faire l’installation d’un deuxième système d’exploitation. Il est fort probable qu’éventuellement il y aura élimination de l’interface graphique, séquençage et restriction du nombre de module exécuté au démarrage. C’est-à-dire désactivation des périphériques superflues. Il reste à déterminé si la recompilation du noyau est avantageuse une fois les correctifs apportés.  
